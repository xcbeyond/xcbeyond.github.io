<!DOCTYPE html>
<html lang="zh-cn"><head>
  <meta charset="utf-8">
  
  <title>MySQL性能优化(三)：深入理解索引的这点事 | xcbeyond</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description"
    content="索引经常被人忽略，有时候甚至被误解、误用，糟糕的索引更会导致非常严重的性能问题，清楚理解索引，能够正确的使用它，便于利用它来进行数据库的优化，这才是索引的正确操作。">
  
  <meta name="author" content="xcbeyond">
  <meta name="generator" content="Hugo 0.81.0" />
  <!-- multilingual SEO optimizations -->
  
  <!-- baidu-site-verification -->
  <meta name="baidu-site-verification" content="code-uBVGWgwQY4" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://xcbeyond.cn/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://xcbeyond.cn/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="https://xcbeyond.cn/plugins/animate/animate.css">
  
  <link rel="stylesheet" href="https://xcbeyond.cn/plugins/venobox/venobox.css">
  
  <link rel="stylesheet" href="https://xcbeyond.cn/plugins/themify-icons/themify-icons.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://xcbeyond.cn/scss/style.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://xcbeyond.cn/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://xcbeyond.cn/images/favicon.png" type="image/x-icon">

</head><body>
<header class="header">
  
  
  
  <div class="navigation w-100 ">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-dark p-0">
        <a class="navbar-brand" href="/"><img class="img-fluid"
            src="https://xcbeyond.cn/images/logo.png" alt="xcbeyond"></a>
        <button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="https://xcbeyond.cn">首页</a>
            </li>
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://xcbeyond.cn/blog">博客</a>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown">
                文档
              </a>
              <div class="dropdown-menu">
                
                <a class="dropdown-item" href="https://xcbeyond.cn/golang-handbook">Golang 实践手册</a>
                
                <a class="dropdown-item" href="https://xcbeyond.cn/istio-handbook">Istio 实践手册</a>
                
                <a class="dropdown-item" href="https://xcbeyond.cn/kubernetes-handbook">Kubernetes 实践手册</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="https://xcbeyond.cn/about">关于</a>
            </li>
            
            
          </ul>

          
          
        </div>
      </nav>
    </div>
  </div>
</header>


	
<section class="page-title-section overlay" style="background-image: url('/'),url('/images/backgrounds/page-title.jpg');" >
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <ul class="list-inline custom-breadcrumb">
          
          <li class="list-inline-item text-white h3 font-secondary">MySQL性能优化(三)：深入理解索引的这点事</li>
        </ul>
        <p class="text-lighten">索引经常被人忽略，有时候甚至被误解、误用，糟糕的索引更会导致非常严重的性能问题，清楚理解索引，能够正确的使用它，便于利用它来进行数据库的优化，这才是索引的正确操作。</p>
      </div>
    </div>
  </div>
</section>
	


<section class="section-sm">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 order-2 order-lg-1">
        <div class="row">
          <div class="col-12 mb-4">
            <img src="/images/blog/mysql-performance-optimization-03.png" alt="blog-thumb" class="img-fluid w-100">
          </div>
          <div class="col-12">
            <ul class="list-inline">
              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">作者
                  :</span><a
                  href="/author/xcbeyond">Xcbeyond</a></li>

              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">发表于
                  :</span>2020-03-14 17:18:43 </li>

              <li class="list-inline-item mr-4 mb-3 mb-md-0 text-light"><span class="font-weight-bold mr-2">分类
                  :</span><a
                  href="/categories/mysql"> 
                  MySQL</a> </li>

              

            </ul>
          </div>
          
          <div class="col-12 my-4">
            <div class="border-bottom"></div>
          </div>
          
          <div class="col-12 mb-5 content">
            <p>索引，对于良好的数据库性能非常关键。只要提及到数据库性能优化，都会首先想到“索引”，看看表中是否添加索引。尤其是当表中的数据量越来越大时，索引对性能的影响尤为突出。在数据量较小且负载较低时，没有索引或者不恰当索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。</p>
<p>不过，索引却经常被忽略，有时候甚至被误解、误用，在实际使用中经常会遇到糟糕索引而导致的性能问题。本文就索引的概念、类型、优点等方面聊聊，一起深入理解索引的这点事，更有助于你清楚的理解索引，能够正确的使用它，便于利用它来进行数据库的优化。</p>
<h2 id="一什么是索引">一、什么是索引</h2>
<p>索引(<code>Index</code>)，是帮助MySQL高效获取数据的数据结构，是存储引擎用于快速找到记录的一种数据结构。</p>
<p>要理解 MySQL 中索引是如何工作的，最简单的例子就是去看看一本书的目录“索引”部分。如果想在一本书中找到某个章节，一般我们会先看书的目录“索引”，就会立即找到对应的页码。</p>
<p>在 MySQL 中，存储引擎也是用类似的方法使用索引，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。</p>
<p>查询是数据库中最常用的操作，我们都希望查询的速度尽可能快，因此数据库系统的设计者会从查询算法角度去进行优化。最基本的查询算法当然就是<strong>顺序查找</strong>，但是这种算法的复杂度为 O(n)，在数据量很大时就会显得非常糟糕。例如，在一张用户表 <code>t_user</code> 中有如下数据，想要查询到年龄为 89 岁的人，如果按照顺序查找，则得逐行扫描，可见查询效率有多低下(数量量越大，数据分布越不均匀，则花费的时间就更长)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t_user;
<span style="color:#f92672">+----+----------+-----+</span>
<span style="color:#f92672">|</span> id <span style="color:#f92672">|</span> name     <span style="color:#f92672">|</span> age <span style="color:#f92672">|</span>
<span style="color:#f92672">+----+----------+-----+</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> xcbeyond <span style="color:#f92672">|</span>  <span style="color:#ae81ff">22</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span> jack     <span style="color:#f92672">|</span>  <span style="color:#ae81ff">34</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span> tom      <span style="color:#f92672">|</span>  <span style="color:#ae81ff">77</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span> kitty    <span style="color:#f92672">|</span>   <span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span> make     <span style="color:#f92672">|</span>  <span style="color:#ae81ff">91</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">6</span> <span style="color:#f92672">|</span> Mickey   <span style="color:#f92672">|</span>  <span style="color:#ae81ff">23</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">7</span> <span style="color:#f92672">|</span> Andy     <span style="color:#f92672">|</span>  <span style="color:#ae81ff">89</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">+----+----------+-----+</span>
<span style="color:#ae81ff">7</span> rows <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span>
</code></pre></div><p>好在，数据库系统的设计者早都意识到了这一点，参考了更优秀的查找算法，如二分查找、二叉树查找等等，但是分析之后发现，每种查找算法都只能应用于特定数据结构之上，如二分查找要求被查询的数据有序，而二叉树查找只能应用于二叉查找树。鉴于此，在数据之外，数据库系统还维护着满足<strong>特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，即：这就是数据库中的<strong>索引</strong>。</p>
<p>为了更好的理解索引，下图就以表 <code>t_user</code> 中的数据，展示了<em>一种可能的索引方式</em>。</p>
<p><img src="%E7%B4%A2%E5%BC%95%E4%B8%BE%E4%BE%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="索引举例示例图"></p>
<p>左边是表中的数据，一共7条记录，为加快 age 列的查找，维护了一个右边所示的二叉查找树，每个节点包含索引键值及一个指向对应数据记录的指针，这样运用二叉查找就能很快的查找对应的数据了，时间复杂度为 <code>O(log2 N)</code>。</p>
<p>然而，在实际数据库中，几乎没有使用这样的二叉查找树来实现（因为二叉查找树对数据是有要求的），但其原理和这类似。</p>
<h2 id="二索引操作">二、索引操作</h2>
<p>在正式介绍索引之前，先一起来看看MySQL是如何创建索引、重建索引、查询索引、删除索引等操作的，以备后续使用。(建议单独保存收藏)</p>
<h3 id="1-创建索引">1. 创建索引</h3>
<p>索引的创建可以在 <code>CREATE TABLE</code> 语句中进行，也可以单独用 <code>CREATE INDEX</code> 或 <code>ALTER TABLE</code> 来给表增加索引。</p>
<p>语法：</p>
<p><code>CREATE [UNIQUE/FULLTEXT] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;)</code></p>
<p><code>ALTER TABLE &lt;表名&gt; ADD INDEX|UNIQUE|PRIMARY KEY|FULLTEXT &lt;索引名&gt;(&lt;列名&gt;)</code></p>
<p>其中，创建索引时，可以指定索引类型：主键索引（<code>PRIMARY KEY</code>）、 唯一索引（<code>UNIQUE</code>）、 全文索引（<code>FULLTEXT</code>）、 普通索引（<code>INDEX</code>）。</p>
<p>例如：</p>
<p>1）以表 <code>index_test</code> 为例说明，先创建一个普通的表 <code>index_test</code>：</p>
<p>(创建表时，也可以直接创建索引，此处为了说明索引的创建，则单独创建索引)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">index_test</span>(id <span style="color:#66d9ef">int</span>,ch <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">32</span>));
Query OK, <span style="color:#ae81ff">0</span> rows affected
</code></pre></div><p>2）为表 <code>index_test</code> 单独创建索引：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">index</span> idx <span style="color:#66d9ef">on</span> <span style="color:#a6e22e">index_test</span>(id);
Query OK, <span style="color:#ae81ff">0</span> rows affected
Records: <span style="color:#ae81ff">0</span>  Duplicates: <span style="color:#ae81ff">0</span>  Warnings: <span style="color:#ae81ff">0</span>
</code></pre></div><p>或者</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> index_test <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">index</span> <span style="color:#a6e22e">idx</span>(id);
Query OK, <span style="color:#ae81ff">0</span> rows affected
Records: <span style="color:#ae81ff">0</span>  Duplicates: <span style="color:#ae81ff">0</span>  Warnings: <span style="color:#ae81ff">0</span>
</code></pre></div><h3 id="2重建索引">2.重建索引</h3>
<p>重建索引，在常规的数据库维护操作中经常使用。在数据库运行了较长时间后，索引都有损坏的可能，这时就需要重建。对数据重建索引可以起到提高检索效率。</p>
<p>重建索引，实质上的对表的修复。</p>
<p>例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> repair <span style="color:#66d9ef">table</span> index_test quick;
<span style="color:#f92672">+-----------------+--------+----------+---------------------------------------------------------+</span>
<span style="color:#f92672">|</span> <span style="color:#66d9ef">Table</span>           <span style="color:#f92672">|</span> Op     <span style="color:#f92672">|</span> Msg_type <span style="color:#f92672">|</span> Msg_text                                                <span style="color:#f92672">|</span>
<span style="color:#f92672">+-----------------+--------+----------+---------------------------------------------------------+</span>
<span style="color:#f92672">|</span> test.index_test <span style="color:#f92672">|</span> repair <span style="color:#f92672">|</span> note     <span style="color:#f92672">|</span> The storage <span style="color:#66d9ef">engine</span> <span style="color:#66d9ef">for</span> the <span style="color:#66d9ef">table</span> doesn<span style="color:#e6db74">&#39;t support repair |
</span><span style="color:#e6db74">+-----------------+--------+----------+---------------------------------------------------------+
</span><span style="color:#e6db74">1 row in set
</span></code></pre></div><h3 id="3-查询索引">3. 查询索引</h3>
<p>有时，为了查看某张表是否有索引，索引情况如何，就需要通过命令 <code>show index from|in table_name</code> 来查看索引。</p>
<p>语法:</p>
<p><code>SHOW INDEX FROM|IN &lt;表名&gt;</code></p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">show</span> <span style="color:#66d9ef">index</span> <span style="color:#66d9ef">from</span> index_test;
<span style="color:#f92672">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
<span style="color:#f92672">|</span> <span style="color:#66d9ef">Table</span>      <span style="color:#f92672">|</span> Non_unique <span style="color:#f92672">|</span> Key_name <span style="color:#f92672">|</span> Seq_in_index <span style="color:#f92672">|</span> Column_name <span style="color:#f92672">|</span> Collation <span style="color:#f92672">|</span> Cardinality <span style="color:#f92672">|</span> Sub_part <span style="color:#f92672">|</span> Packed <span style="color:#f92672">|</span> <span style="color:#66d9ef">Null</span> <span style="color:#f92672">|</span> Index_type <span style="color:#f92672">|</span> Comment <span style="color:#f92672">|</span> Index_comment <span style="color:#f92672">|</span>
<span style="color:#f92672">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
<span style="color:#f92672">|</span> index_test <span style="color:#f92672">|</span>          <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> idx      <span style="color:#f92672">|</span>            <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> id          <span style="color:#f92672">|</span> A         <span style="color:#f92672">|</span>           <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">NULL</span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">NULL</span>   <span style="color:#f92672">|</span> YES  <span style="color:#f92672">|</span> BTREE      <span style="color:#f92672">|</span>         <span style="color:#f92672">|</span>               <span style="color:#f92672">|</span>
<span style="color:#f92672">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span>
<span style="color:#ae81ff">1</span> row <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span>
</code></pre></div><blockquote>
<p>细心的你，或许看到查询结果中的字段 <code>index_type</code> 的值 <code>BTREE</code>，这也就是接下来会讲到的 <code>B Tree</code> 索引，从另一方面也可以知道 <code>InnoDB</code> 默认的索引类型为 <code>B Tree</code>。</p>
</blockquote>
<h3 id="4-删除索引">4. 删除索引</h3>
<p>删除索引可以使用 <code>DROP INDEX</code> 或 <code>ALTER TABLE</code> 语句来实现。</p>
<p>语法：</p>
<p><code>DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;</code></p>
<p><code>ALTER TABLE &lt;表名&gt; DROP INDEX &lt;索引名&gt;</code></p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">index</span> idx <span style="color:#66d9ef">on</span> index_test;
Query OK, <span style="color:#ae81ff">0</span> rows affected
Records: <span style="color:#ae81ff">0</span>  Duplicates: <span style="color:#ae81ff">0</span>  Warnings: <span style="color:#ae81ff">0</span>
</code></pre></div><p>或者</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> index_test <span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">index</span> idx;
Query OK, <span style="color:#ae81ff">0</span> rows affected
Records: <span style="color:#ae81ff">0</span>  Duplicates: <span style="color:#ae81ff">0</span>  Warnings: <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="三索引类型">三、索引类型</h2>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，<strong>索引是在存储引擎层实现的</strong>，所以，并没有统一的索引标准：<strong>不同存储引擎的索引的工作方式也是不一样的</strong>，也不是所有的存储引擎都支持所有类型的索引。</p>
<p>从存储结构上来划分：</p>
<ul>
<li>BTree 索引（B-Tree 或 B+Tree 索引）</li>
<li>哈希索引</li>
<li>全文索引（full-index）</li>
</ul>
<p>从应用层次来分：</p>
<ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。</li>
<li>复合索引：即一个索引包含多个列。</li>
</ul>
<p>下面我们从索引的存储结构上，来看看 MySQL 支持的索引类型，底层是如何实现的，以及它们的优缺点。</p>
<blockquote>
<p>MySQL 默认存储引擎是 <code>Innodb</code>，只显式支持 <code>B-Tree</code> 索引，对于频繁访问的表，<code>Innodb</code> 会透明建立自适应哈希索引，即在B树索引基础上建立哈希索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</p>
</blockquote>
<h3 id="1-b-tree索引">1. B-Tree索引</h3>
<p>当大家在谈论索引的时候，如果没有特别指明类型，多半说的是 <code>B-Tree</code> 索引，它使用B-Tree数据结构来存储数据，可以让系统高效的找到数据所在的磁盘块。</p>
<blockquote>
<p>B 代表平衡(balance)，而不是二叉(binary)，因为 <code>B-Tree</code> 是从最早的平衡二叉树演化而来的。</p>
</blockquote>
<p><code>B-Tree</code> 是为磁盘等外存储设备设计的一种平衡查找树。因此在讲 <code>B-Tree</code> 之前先了解下磁盘的相关知识。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p><code>InnoDB</code> 存储引擎中有页（<code>Page</code>）的概念，页是其磁盘管理的最小单位。<code>InnoDB</code> 存储引擎中默认每个页的大小为 16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;innodb_page_size&#39;</span>;
<span style="color:#f92672">+------------------+-------+</span>
<span style="color:#f92672">|</span> Variable_name    <span style="color:#f92672">|</span> Value <span style="color:#f92672">|</span>
<span style="color:#f92672">+------------------+-------+</span>
<span style="color:#f92672">|</span> innodb_page_size <span style="color:#f92672">|</span> <span style="color:#ae81ff">16384</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">+------------------+-------+</span>
<span style="color:#ae81ff">1</span> row <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span>
</code></pre></div><p>而系统一个磁盘块的存储空间往往没有这么大，因此 <code>InnoDB</code> 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。<code>InnoDB</code> 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p>
<p>B-Tree 定义数据记录为一个二元组[key、data]：</p>
<ul>
<li>
<p><code>key</code> 为记录的主键，即表中的主键值，用于记录唯一的数据行，key 值是唯一且互不相同的。</p>
</li>
<li>
<p><code>data</code> 为一行记录中除主键外的数据。</p>
</li>
</ul>
<p>一棵 m 阶的 B-Tree 有如下特性：</p>
<ul>
<li>每个节点最多有 m 个孩子。</li>
<li>除了根节点和叶子节点外，其它每个节点至少有 ceil(m/2) 个孩子。</li>
<li>若根节点不是叶子节点，则至少有 2 个孩子。</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息。</li>
<li>每个非终端节点包含 n 个关键字信息（p0,p1,&hellip;pn,k1,&hellip;kn）</li>
<li>关键字 key 的个数 n 满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n) 为关键字，且关键字升序排序。</li>
<li>pi(i=1,…n) 为指向子节点的指针。p(i-1) 指向的子树的所有节点关键字均小于 ki，但都大于 k(i-1)。</li>
</ul>
<p><em>注：<code>ceil()</code> 为取整函数。</em></p>
<p>B-Tree 中的每个节点根据实际情况，可以包含大量的键值 <code>key</code>、数据 <code>data</code>、和指针 <code>p</code>。如下图所示为一个 3 阶的 B-Tree 索引结构：</p>
<p><img src="B-Tree%E7%B4%A2%E5%BC%95%E4%B8%BE%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="B-Tree索引举例示意图"></p>
<p>每个节点占用一个磁盘块空间，一个节点上有两个升序排序的关键字 key 和三个指向子节点的指针 p，指针存储的是子节点所在磁盘块的地址。两个关键词 key 划分成为三个范围域对应的三个指针 p，并指向的子节点的数据的范围域。以根节点为例，关键字为 17 和 35，p1 指针指向的子节点的数据范围为小于 17，p2 指针指向的子节点的数据范围为 17~35，p3 指针指向的子节点的数据范围为大于 35。</p>
<p>模拟查找关键字为 <code>29</code> 数据行的过程：</p>
<ol>
<li>
<p>根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】</p>
</li>
<li>
<p>比较关键字 <code>29</code> 在区间 （17,35），找到磁盘块 1 的指针 p2。</p>
</li>
<li>
<p>根据 p2 指针找到磁盘块3，读入内存。【磁盘 I/O 操作第 2 次】</p>
</li>
<li>
<p>比较关键字 <code>29</code> 在区间 （26,30），找到磁盘块 3 的指针 p2。</p>
</li>
<li>
<p>根据 p2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】</p>
</li>
<li>
<p>在磁盘块 8 中的关键字列表中找到关键字 <code>29</code>。</p>
</li>
</ol>
<p>分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的关键字 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。 B-Tree 相对于 <code>AVLTree</code>(高度平衡的二叉树)缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h3 id="2-btree索引">2. B+Tree索引</h3>
<p><code>B+Tree</code> 是在 <code>B-Tree</code> 基础上的一种优化，使其更适合实现存储索引结构，<code>InnoDB</code> 存储引擎就是用 <code>B+Tree</code> 实现其索引结构。</p>
<p>从上一节中的 <code>B-Tree</code> 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 <code>B-Tree</code> 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 <code>B+Tree</code> 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 <code>B+Tree</code> 的高度。</p>
<p><code>B+Tree</code> 相对于 <code>B-Tree</code> 有几点不同：</p>
<ul>
<li>
<p>非叶子节点只存储键值信息。</p>
</li>
<li>
<p>所有叶子节点之间都有一个链指针。</p>
</li>
<li>
<p>数据记录都存放在叶子节点中。</p>
</li>
</ul>
<p>将上一小节中的 <code>B-Tree</code> 进行优化，由于 <code>B+Tree</code> 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 <code>B+Tree</code> 后其结构如下图所示：</p>
<p><img src="B+Tree%E7%B4%A2%E5%BC%95%E4%B8%BE%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="B+Tree索引举例示意图"></p>
<p>通常在 <code>B+Tree</code> 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 <code>B+Tree</code> 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p>
<p>可能上面例子中只有22条数据记录，看不出 <code>B+Tree</code> 的优点，下面做一个推算：</p>
<p><code>InnoDB</code> 存储引擎中页的大小为 16KB，一般表的主键类型为 <code>INT</code>（占用4个字节）或 <code>BIGINT</code>（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（<code>B+Tree</code> 中的一个节点）中大概存储<code>16KB/(8B+8B)=1K</code> 个键值（因为是估值，为方便计算，这里的K取值为 10^3）。也就是说一个深度为 3 的 <code>B+Tree</code> 索引可以维护 <code>10^3 * 10^3 * 10^3 = 10亿</code> 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL 的 <code>InnoDB</code> 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。</p>
<h3 id="3-哈希索引">3. 哈希索引</h3>
<p>哈希索引(<code>hash index</code>)，是<strong>基于哈希表实现的</strong>。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希值(<code>hash value</code>)，不同键值的行计算出来的哈希值也不一样。<strong>哈希索引将所有的哈希值存储在索引中，同时在哈希表中保存指向每个数据行的指针。</strong></p>
<p><strong>在MySQL中，只有 <code>Memory</code> 引擎显示支持哈希索引，同时哈希索引也是 <code>Memory</code> 存储引擎的默认索引类型</strong>，并且 <code>Memory</code> 存储引擎也是支持 <code>B-Tree</code> 索引。</p>
<p>如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希值。</p>
<p>继续以表 <code>t_user</code> 中的数据举例说明，并对字段 <code>name</code> 设置哈希索引。假设索引使用的哈希函数是 <code>f()</code>，则计算出来的哈希值(都是举例数据，并非真实数据)为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;xcbeyond&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">2390</span>

<span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;jack&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">4010</span>

<span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;tom&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">5178</span>

<span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;kitty&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">1067</span>

<span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;make&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">7901</span>

<span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;Mickey&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">3079</span>

<span style="color:#a6e22e">f</span>(<span style="color:#e6db74">&#39;Andy&#39;</span>)<span style="color:#f92672">=</span><span style="color:#ae81ff">8301</span>
</code></pre></div><p>计算出来的哈希值，会指向对应数据行的数据，指向关系如下图:</p>
<p><img src="%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%BE%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="哈希索引举例示意图"></p>
<p>执行如下查询，并能够查询到对应的数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t_user <span style="color:#66d9ef">where</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;xcbeyond&#39;</span>;
<span style="color:#f92672">+----+----------+-----+</span>
<span style="color:#f92672">|</span> id <span style="color:#f92672">|</span> name     <span style="color:#f92672">|</span> age <span style="color:#f92672">|</span>
<span style="color:#f92672">+----+----------+-----+</span>
<span style="color:#f92672">|</span>  <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> xcbeyond <span style="color:#f92672">|</span>  <span style="color:#ae81ff">22</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">+----+----------+-----+</span>
<span style="color:#ae81ff">1</span> row <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span>
</code></pre></div><p>先计算出 <code>xcbeyond</code> 的哈希值，根据该哈希值寻找到对应指向的数据行。<code>f('xcbeyond')=2390</code>，所以MySQL在索引中查找 2390，并找到指向第 1 行的数据行，然后比较第 1 行的值是否等于 <code>xcbeyond</code>，以确保查找到数据的准确性。</p>
<p>**因为索引自身只需存储对应的哈希值，所有索引的结构十分紧凑，这也让哈希索引查找的速度非常快。**然而，哈希索引也有它的限制，即：索引失效。</p>
<ul>
<li><strong>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。</strong></li>
<li><strong>哈希索引不支持部分索引列匹配查找</strong>，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列 (A,B) 上都建立哈希索引，如果查询时只有数据列 A，则无法使用该索引。</li>
<li><strong>哈希索引只支持等比较查询</strong>，包括 <code>=</code>、<code>in()</code>，<strong>不支持任何范围、模糊查找</strong>，例如，<code>where age &gt; 20</code>、<code>where name like '%xc%'</code>。</li>
<li>如果哈希冲突很多的话，存储引擎必须进行链表来维护，维护这些链表的操作代价会很大，则查询的性能会很低。</li>
</ul>
<h3 id="4-全文索引">4. 全文索引</h3>
<p>全文索引是一种特殊类型的索引，<strong>它查找的是文本中的关键字，而不是比较索引中的值</strong>。</p>
<p>全文索引和其他类型索引的匹配方式完全不一样，它有许多需要注意的细节。更类似于搜索引擎做的事情，而不是简单的 where 条件匹配。</p>
<p>在相同的列上同时创建全文索引和基于值的B-Tree索引是不会有冲突的，<strong>全文索引适用于全文模糊搜索(MATCH AGAINST)操作，而不是普通的 where 条件操作</strong>。</p>
<h2 id="四索引优点">四、索引优点</h2>
<p>索引可以让 MySQL 服务器快速地定位到表的指定位置，但这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。</p>
<p>最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 ORDER BY 和 GROUP BY 操作。因为数据是有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下优点：</p>
<ul>
<li>索引大大减少了 MySQL 服务器需要扫描的数据量。(全表扫描)</li>
<li>索引可以帮助 MySQL 服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
</ul>
<p><strong>索引是最好的解决方案吗？</strong></p>
<p>索引并不总是最好的方案。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长，这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配，如可以采用表分区的方式。</p>
<p>如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。例如执行那些需要聚合多个应用分布在多个表的数据的查询，则需要记录“哪个用户的信息存放在哪个表中”的元数据，这样在查询时就可以直接忽略那些不包含指定用户信息的表。对于大型系统，这是一个常用的技巧。</p>
<p>参考文章：</p>
<ol>
<li><a href="https://www.jianshu.com/p/d67c637776d6">https://www.jianshu.com/p/d67c637776d6</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1125452">https://cloud.tencent.com/developer/article/1125452</a></li>
</ol>

          </div>
          
          
          <div class="col-12">
            
            
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
	window.onload = function() {
        const gitalk = new Gitalk({
        clientID: 'c10f597904f9726fdd0e',
        clientSecret: '7e2bcbbd69c3b6369893995ff81aec88e4b53800',
        repo: 'xcbeyond.github.io',
        owner: 'xcbeyond',
        admin: ['xcbeyond'],
        id: location.pathname, 
        distractionFreeMode: false 
      });
      (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
          document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
          return;
        }
        gitalk.render('gitalk-container');
      })();
    }
</script>
          </div>
          
        </div>
      </div>
      <!-- sidebar -->
<aside class="col-lg-4 order-1 order-lg-2">
  <!-- categories -->
  <div class="bg-white mb-5">
    <h4 class="mb-4">分类</h4>
    <ul class="list-unstyled">
      <li class="border-bottom"><a href="/categories/go" class="d-block pb-3 mt-3">Go</a></li>
      <li class="border-bottom"><a href="/categories/kubernetes" class="d-block pb-3 mt-3">Kubernetes</a></li>
      <li class="border-bottom"><a href="/categories/mysql" class="d-block pb-3 mt-3">Mysql</a></li>
      <li class="border-bottom"><a href="/categories/service-mesh" class="d-block pb-3 mt-3">Service mesh</a></li>
      <li class="border-bottom"><a href="/categories/%e4%b8%ad%e5%8f%b0" class="d-block pb-3 mt-3">中台</a></li>
      <li class="border-bottom"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="d-block pb-3 mt-3">云原生</a></li>
      <li class="border-bottom"><a href="/categories/%e5%85%b6%e4%bb%96" class="d-block pb-3 mt-3">其他</a></li>
      <li class="border-bottom"><a href="/categories/%e5%ae%b9%e5%99%a8" class="d-block pb-3 mt-3">容器</a></li>
      <li class="border-bottom"><a href="/categories/%e5%be%ae%e6%9c%8d%e5%8a%a1" class="d-block pb-3 mt-3">微服务</a></li>
      <li class="border-bottom"><a href="/categories/%e7%a8%8b%e5%ba%8f%e4%ba%ba%e7%94%9f" class="d-block pb-3 mt-3">程序人生</a></li>
      <li class="border-bottom"><a href="/categories/%e8%af%84%e6%b5%8b" class="d-block pb-3 mt-3">评测</a></li>
    </ul>
  </div>
  <!-- tags -->
  <div class="bg-white mb-5">
    <h4 class="mb-4">标签</h4>
    <ul class="list-inline tag-list">
      <li class="list-inline-item mb-2"><a href="/tags/cobra">Cobra</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/devops">Devops</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/docker">Docker</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/dockerfile">Dockerfile</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/gateway">Gateway</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/go%e8%af%ad%e8%a8%80%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a">Go语言从入门到精通</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/hugo">Hugo</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/infoq">Infoq</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/ingress">Ingress</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/istio">Istio</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/kubernetes%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a">Kubernetes从入门到精通</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/markdown">Markdown</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/mysql%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96">Mysql性能优化</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/service-mesh">Service mesh</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/spring-cloud">Spring cloud</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/tcp">Tcp</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/website">Website</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/yapi">Yapi</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/%e4%ba%91%e6%95%88">云效</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2">安装部署</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/%e6%9c%8d%e5%8a%a1%e6%8b%86%e5%88%86">服务拆分</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/%e7%9b%98%e7%82%b92021">盘点2021</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/%e7%b4%a2%e5%bc%95">索引</a></li>
      <li class="list-inline-item mb-2"><a href="/tags/%e9%95%9c%e5%83%8f">镜像</a></li>
    </ul>
  </div>
  <!-- latest post -->
  <div class="bg-white">
    <h4 class="mb-4">最新文章</h4>
    <!-- post-item -->
    
    <div class="media border-bottom border-color pb-3 mb-3">
      <a href="https://xcbeyond.cn/blog/cloudnative/exposing-tcp-services/"><img class="mr-3 post-thumb-sm" src="https://xcbeyond.cn/images/blog/transfer.jpeg"></a>
      <div class="media-body">
        <a href="https://xcbeyond.cn/blog/cloudnative/exposing-tcp-services/">
          <h5 class="mt-0">如何通过 kubernetes ingress 或者 istio ingressgateway 来暴露 TCP 的服务</h5>
        </a>
        2023-04-05 00:13:10
      </div>
    </div>
    
    <div class="media border-bottom border-color pb-3 mb-3">
      <a href="https://xcbeyond.cn/blog/kubernetes/installation-chapter-part3-deploy-cluster-environment-based-on-kind/"><img class="mr-3 post-thumb-sm" src="https://xcbeyond.cn/images/blog/kind.png"></a>
      <div class="media-body">
        <a href="https://xcbeyond.cn/blog/kubernetes/installation-chapter-part3-deploy-cluster-environment-based-on-kind/">
          <h5 class="mt-0">Kubernetes安装篇（三）：基于kind快速部署本地多套K8S集群</h5>
        </a>
        2023-04-01 22:49:19
      </div>
    </div>
    
    <div class="media border-bottom border-color pb-3 mb-3">
      <a href="https://xcbeyond.cn/blog/containers/dockerfile-best-practices/"><img class="mr-3 post-thumb-sm" src="https://xcbeyond.cn/images/blog/dockerfile-best-practices.png"></a>
      <div class="media-body">
        <a href="https://xcbeyond.cn/blog/containers/dockerfile-best-practices/">
          <h5 class="mt-0">Dockerfile 的最佳实践 ｜ Dockerfile 你写的都对么？</h5>
        </a>
        2022-05-14 21:40:14
      </div>
    </div>
    
    <div class="media border-bottom border-color pb-3 mb-3">
      <a href="https://xcbeyond.cn/blog/others/devops-is-no-longer-just-jenkins/"><img class="mr-3 post-thumb-sm" src="https://xcbeyond.cn/images/blog/aliyun-devops.png"></a>
      <div class="media-body">
        <a href="https://xcbeyond.cn/blog/others/devops-is-no-longer-just-jenkins/">
          <h5 class="mt-0">谈阿里云云效 DevOps | DevOps 不再只是 Jenkins</h5>
        </a>
        2022-03-26 21:06:50
      </div>
    </div>
    
    <div class="media border-bottom border-color pb-3 mb-3">
      <a href="https://xcbeyond.cn/blog/containers/build-multi-platform-images-best-practices/"><img class="mr-3 post-thumb-sm" src="https://xcbeyond.cn/images/blog/multi-platform-images.png"></a>
      <div class="media-body">
        <a href="https://xcbeyond.cn/blog/containers/build-multi-platform-images-best-practices/">
          <h5 class="mt-0">构建多架构镜像的最佳实践</h5>
        </a>
        2022-01-22 09:56:55
      </div>
    </div>
    
    <div class="media border-bottom border-color pb-3 mb-3">
      <a href="https://xcbeyond.cn/blog/cloudnative/cloudnative-embrace-road/"><img class="mr-3 post-thumb-sm" src="https://xcbeyond.cn/images/blog/cloudnative-01.jpeg"></a>
      <div class="media-body">
        <a href="https://xcbeyond.cn/blog/cloudnative/cloudnative-embrace-road/">
          <h5 class="mt-0">盘点 2021 ｜ 云原生拥抱之路</h5>
        </a>
        2021-12-31 21:18:56
      </div>
    </div>
    
  </div>
  <!-- toc -->
  
  <div class="bg-white px-4 py-5 box-shadow mb-5 sticky-top">
    <h4 class="mb-4">目录</h4>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一什么是索引">一、什么是索引</a></li>
    <li><a href="#二索引操作">二、索引操作</a>
      <ul>
        <li><a href="#1-创建索引">1. 创建索引</a></li>
        <li><a href="#2重建索引">2.重建索引</a></li>
        <li><a href="#3-查询索引">3. 查询索引</a></li>
        <li><a href="#4-删除索引">4. 删除索引</a></li>
      </ul>
    </li>
    <li><a href="#三索引类型">三、索引类型</a>
      <ul>
        <li><a href="#1-b-tree索引">1. B-Tree索引</a></li>
        <li><a href="#2-btree索引">2. B+Tree索引</a></li>
        <li><a href="#3-哈希索引">3. 哈希索引</a></li>
        <li><a href="#4-全文索引">4. 全文索引</a></li>
      </ul>
    </li>
    <li><a href="#四索引优点">四、索引优点</a></li>
  </ul>
</nav>
  </div>
</aside>
<!-- /sidebar -->
    </div>
  </div>
</section>



<footer>
  
  
  
  
  
  <div class="copyright py-4 bg-footer">
    <div class="container">
      <div class="row">
        <div class="col-sm-7 text-sm-left text-center">
          <p class="mb-0">Copyright © 2021-2023 xcbeyond 版权所有.
            
          </p>
        </div>
        <div class="col-sm-5 text-sm-right text-center">
          <ul class="list-inline">
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="https://xcbeyond.blog.csdn.net/"><i class="ti-facebook text-primary"></i></a></li>
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="https://mp.weixin.qq.com/s/Wr0RS2BBXTSJI82pck2aXw"><i class="ti-instagram text-primary"></i></a></li>
            
            <li class="list-inline-item"><a class="d-inline-block p-2" href="https://github.com/xcbeyond"><i class="ti-github text-primary"></i></a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>


<!-- Google Map API -->


<!-- JS Plugins -->

<script src="https://xcbeyond.cn/plugins/jQuery/jquery.min.js"></script>

<script src="https://xcbeyond.cn/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://xcbeyond.cn/plugins/slick/slick.min.js"></script>

<script src="https://xcbeyond.cn/plugins/venobox/venobox.min.js"></script>

<script src="https://xcbeyond.cn/plugins/filterizr/jquery.filterizr.min.js"></script>


<!-- Main Script -->

<script src="https://xcbeyond.cn/js/script.min.js"></script>

<!-- google analitycs -->







</body>

</html>